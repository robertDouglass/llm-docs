# Building Go-based MCP Servers: Logging in Claude Desktop & Codename Goose (macOS)

## Capturing Debug Output in Claude Desktop & Goose Logs 
When your MCP server runs in **stdio mode**, the host clients (Claude Desktop or Goose) capture everything you print to **stderr** and save it to their logs ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=Server)) ([For Claude Desktop Users - Model Context Protocol](https://modelcontextprotocol.io/quickstart/user#:~:text=,MCP%20connections%20and%20connection%20failures)). To make your debug output visible, log to stderr (e.g. using Go’s `log` package). **Do not log to stdout**, because stdout is reserved for the MCP JSON protocol messages – extra text there can confuse or break the protocol ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=logged%20to%20stderr%20,Claude%20Desktop%29%20automatically)). For example, instead of `fmt.Println("Debug info")` (which writes to stdout), use: 

```go
import "log"
// ...
log.Println("Debug info")  // goes to stderr, captured by host
``` 

Go’s standard `log` package writes to stderr by default, so `log.Printf`/`log.Println` are safe for emitting debug logs. This way, any debug or error messages you print will appear in the Claude Desktop or Goose log files automatically ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=Server)). 

## How Claude Desktop Logs MCP Server Output 
**Claude Desktop** launches MCP server processes and funnels their stderr output into log files on macOS. You can find these logs under `~/Library/Logs/Claude/` ([For Claude Desktop Users - Model Context Protocol](https://modelcontextprotocol.io/quickstart/user#:~:text=Claude,written%20to%20log%20files%20in)). There will be a file named **`mcp-server-<YourServerName>.log`** containing the server’s stderr output (the Claude docs refer to this as “error (stderr) logging” from your server) ([For Claude Desktop Users - Model Context Protocol](https://modelcontextprotocol.io/quickstart/user#:~:text=,MCP%20connections%20and%20connection%20failures)). 

Everything your Go server writes to stderr – startup messages, tool call traces, panics, etc. – will end up in that log file. By contrast, anything written to stdout is treated as part of the MCP protocol (JSON-RPC messages) and **not** recorded in the log ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=logged%20to%20stderr%20,Claude%20Desktop%29%20automatically)). Claude’s official guide emphasizes that local servers *“should not log messages to stdout… as this will interfere with protocol operation.”* ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=logged%20to%20stderr%20,Claude%20Desktop%29%20automatically)) In practice, that means your server’s normal stdout output is consumed as Claude’s incoming messages, not as log text.

To view the logs, you can use the macOS Console app or simply tail the files in Terminal. For example: 

```bash
tail -f ~/Library/Logs/Claude/mcp-server-<YourServerName>.log
``` 

will live-stream your server’s stderr logs ([For Claude Desktop Users - Model Context Protocol](https://modelcontextprotocol.io/quickstart/user#:~:text=You%20can%20run%20the%20following,will%20only%20show%20recent%20logs)). Claude Desktop also provides a UI to access logs – go to **Settings → Developer** in the app, which opens the logs folder (and you’ll see files like `mcp.log` and your server’s log) ([Tutorial: Creating and Using a Brave Search MCP Server in Claude Desktop • Valyu Blog](https://www.valyu.network/blog/brave-search-mcp-server-claude#:~:text=tail%20)). The `mcp.log` contains general MCP connection info ([For Claude Desktop Users - Model Context Protocol](https://modelcontextprotocol.io/quickstart/user#:~:text=%2A%20Windows%3A%20%60)), while `mcp-server-*.log` is specific to each server’s stderr output. 

**Tip:** If you’re not seeing expected debug output in Claude’s logs, double-check that you’re using stderr. For example, Go’s `log.Fatal(err)` on startup errors writes to stderr (and will appear in the logs) ([GitHub - gomcpgo/mcp: A Go framework for building Model Context Protocol (MCP) servers that enable Large Language Models (LLMs) to securely access tools and data sources.](https://github.com/gomcpgo/mcp#:~:text=srv%20%3A%3D%20server.New%28server.Options,Registry%3A%20registry%2C)), whereas a bare `fmt.Println` would not be captured. 

## How Goose (Codename Goose) Logs MCP Server Output 
**Codename Goose**, an open-source AI agent, also captures subprocess output in stdio mode. When you add a custom MCP extension to Goose (which runs your Go server), Goose will capture the server’s stderr and record it. Goose stores logs under your home directory as well. On macOS/Linux, check `~/.local/state/goose/logs/` for Goose logs ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=match%20at%20L111%20%2A%20Unix,Block%5Cgoose%5Cdata%5Clogs%5Cgoose.log)) ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=Server%20logs%20are%20stored%20in%3A)). The “Main” Goose application log is `~/Library/Application Support/Goose/logs/main.log` on macOS ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=The%20desktop%20application%20maintains%20its,own%20logs)), and there are subdirectories for CLI and server logs ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=CLI%20Logs)) ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=match%20at%20L160%20%2A%20Unix,Block%5Cgoose%5Cdata%5Clogs%5Cserver)). Goose’s **server logs** (in `logs/server/`) include the daemon’s operations and also extension init/output details ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=,level%20transport%20information)) ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=The%20Server%20logs%20contain%20information,the%20CLI%2C%20extensions%2C%20and%20LLMs)). 

Goose labels plugin outputs as **extension logs**, which contain tool initialization info, schema details, and importantly any error or debug messages from the extension ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=Extension%20logs%20contain%3A)). In other words, your MCP server’s stderr is captured by Goose and ends up in Goose’s log files as part of the extension’s logs. For example, if your Go server panics or prints an error to stderr, you’ll find the stack trace or message in Goose’s logs. One Goose user report showed a Rust-based extension’s panic (on stderr) being reported as a “Stdio process error” with the panic details in Goose’s output ([goose session -> Failed to start the MCP server from configuration `Builtin(developer)` `Call to '' failed for 'initialize'. Error from mcp-server: Stdio process error: \nthread 'main' panicked · Issue #1392 · block/goose · GitHub](https://github.com/block/goose/issues/1392#:~:text=Failed%20to%20start%20extension%3A%20developer%2C,n)) – confirming that Goose does funnel stderr output from the MCP server into its logs. 

Unlike Claude, Goose currently doesn’t create a separate file per extension by default (it aggregates logs in the state directory), but it still captures all stderr text. Goose’s logging system is quite detailed: the **server logs** even include debug-level transport and message details ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=,level%20transport%20information)). The **extension logs** (which are part of those files) will show any `fmt.Fprintf(os.Stderr, "...")` or `log.Print(...)` calls from your Go code as well as exceptions. Just like with Claude, stdout from the server is used for JSON messages to Goose and is not recorded as log text.

## Increasing Log Verbosity (Debug Levels) 
Both Claude Desktop and Goose will log whatever your server emits to stderr, but sometimes you may want to see more verbose information (either from the server or the client side). Here’s how to maximize debugging info on macOS:

**Claude Desktop:** The Claude app itself doesn’t have an exposed setting to adjust logging level – it already logs key events and captures all server stderr output. To get more detail, you should increase your **server’s** logging verbosity. For instance, add more `log.Println` calls in your Go code for debug-level details (since Claude will capture them all). Claude will faithfully record even debug-level spam from your server in the `mcp-server-*.log` file (it does no filtering on stderr) ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=Server)). In addition, you can enable the Developer Tools console in Claude Desktop to see client-side debug output (though this is more about the Claude UI, not the server). Creating a `~/Library/Application Support/Claude/developer_settings.json` with `{"allowDevTools": true}` and pressing <kbd>Cmd+Option+Shift+I</kbd> opens Chrome DevTools for Claude ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=Using%20Chrome%20DevTools)). In the DevTools console, you might observe MCP client logging or errors on Claude’s side, which can be useful for diagnosing issues beyond your server. But for MCP server debug logs, the **stderr-to-log file** path is the main mechanism – just ensure your Go server is logging at a verbose level to stderr.

**Goose:** Goose (being a CLI/desktop hybrid) uses Rust’s logging infrastructure. By default, its log files include a lot of detail, but you can get even more by running it in debug mode. Launching Goose with the environment variable `RUST_LOG=debug` will turn on debug-level logging within Goose itself (this can show detailed internal states in the Goose server logs). For example, in a terminal you might run: 

```bash
RUST_LOG=debug RUST_BACKTRACE=1 goose session
``` 

When starting Goose from the CLI, this would enable verbose logging and include backtraces on errors ([goose Failed to start extension: (all extensions except Developer) · Issue #1763 · block/goose · GitHub](https://github.com/block/goose/issues/1763#:~:text=RUST_BACKTRACE%3Dfull%20RUST_LOG%3Ddebug%20goose%20session%20Failed,%3Cstd%3A%3Asys%3A%3Abacktrace%3A%3ABacktraceLock%3A%3Aprint%3A%3ADisplayBacktrace%20as)). On macOS, if you’re using the Goose desktop app, you can’t easily set env vars on the app bundle directly, but Goose’s log files are already quite comprehensive (they list JSON-RPC messages, tool definitions, etc. ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=,level%20transport%20information))). If you’re developing, running the CLI with `RUST_LOG=debug` is an option to see extra logs in the console. 

In summary, to increase verbosity, adjust the **server’s logging output** (since the clients always capture stderr), and use the clients’ developer modes for any additional insights. Claude Desktop captures everything on stderr by design (so “verbosity” is about what your server emits), and Goose can be run with debug flags to reveal more of its own operation if needed. 

## Stderr vs Stdout: Verifying Log Capture 
It’s worth reiterating the key point: **Claude Desktop and Goose capture stderr, not stdout, for logging.** Claude’s documentation explicitly states that all messages logged to stderr will be picked up by the host app ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=Server)), and its user guide confirms files like `mcp-server-Name.log` contain the server’s stderr output ([For Claude Desktop Users - Model Context Protocol](https://modelcontextprotocol.io/quickstart/user#:~:text=,MCP%20connections%20and%20connection%20failures)). Goose’s logging guide likewise indicates that extension logs (which include “error messages and debugging information”) are recorded – which corresponds to the extension’s stderr output ([Logging System | codename goose](https://block.github.io/goose/docs/guides/logs#:~:text=Extension%20logs%20contain%3A)). Stdout from your process is consumed as protocol data by the clients, so it is **not** written to log files ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=logged%20to%20stderr%20,Claude%20Desktop%29%20automatically)). In practice, if you accidentally print normal text to stdout in your MCP server, Claude/Goose will likely try to parse it as an MCP JSON message (and either throw an error or ignore it if it’s not valid JSON). Meanwhile, anything on stderr can be freely used for debugging info, and will not interfere with the protocol ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=logged%20to%20stderr%20,Claude%20Desktop%29%20automatically)). 

**Bottom line:** To see your server’s logs in Claude Desktop or Goose, send them to stderr. Use stdout **only** for the JSON-RPC responses and notifications that conform to MCP. This separation ensures your debug logs go to the right place (the client’s log files) and do not break the client-server communication. 

## Logging Behaviors in Go MCP Frameworks 
Several Go libraries have emerged for implementing MCP servers. They differ slightly in how they handle logging. Here’s a comparison with respect to **where they write logs, log structure/levels, protocol safety, and configurability**:

- **gomcpgo/mcp:** A simple Go MCP framework that mostly leaves logging up to you. It uses Go’s standard `log` package for any internal errors (e.g., calling `log.Fatal` on server startup failure) ([GitHub - gomcpgo/mcp: A Go framework for building Model Context Protocol (MCP) servers that enable Large Language Models (LLMs) to securely access tools and data sources.](https://github.com/gomcpgo/mcp#:~:text=srv%20%3A%3D%20server.New%28server.Options,Registry%3A%20registry%2C)), which writes to stderr. It doesn’t print unsolicited information to stdout, so it won’t interfere with the MCP channel. It doesn’t provide built-in structured logging or log level controls – you just insert `log.Printf` or use your own logging as needed. Because it’s minimal, it’s easy to redirect or adjust logging: you can even swap out the logger (e.g., set a custom output or use another logging library) since the framework isn’t opinionated about logging. In short, **gomcpgo/mcp logs only critical errors by default (to stderr) and leaves all other logging to the developer**, making it straightforward to ensure compliance with Claude/Goose logging expectations.

- **go-mcp (MegaGrindStone):** A more full-featured implementation that includes support for progress updates and logging messages as part of the MCP protocol (it can send `LoggingMessageNotification` events to the client) ([mcp package - github.com/mark3labs/mcp-go/mcp - Go Packages](https://pkg.go.dev/github.com/mark3labs/mcp-go/mcp#:~:text=LoggingMessageNotification%20is%20a%20notification%20of,which%20messages%20to%20send%20automatically)). By default, go-mcp does not spam stdout – its core library functions don’t print to stdout except when you explicitly do so. In the provided examples, however, you’ll see it using `fmt.Printf` in event handlers (for instance, printing “Client connected” or progress updates) ([GitHub - MegaGrindStone/go-mcp: A Go implementation of the Model Context Protocol (MCP) - an open protocol that enables seamless integration between LLM applications and external data sources and tools.](https://github.com/MegaGrindStone/go-mcp#:~:text=fmt.Printf%28%22Client%20connected%3A%20,s%5Cn%22%2C%20id)) ([GitHub - MegaGrindStone/go-mcp: A Go implementation of the Model Context Protocol (MCP) - an open protocol that enables seamless integration between LLM applications and external data sources and tools.](https://github.com/MegaGrindStone/go-mcp#:~:text=match%20at%20L597%20fmt.Printf%28%22Progress%3A%20,Total%29)). **Be aware**: those example prints go to stdout, so if you copy them into a stdio-based server, you should change them to log to stderr (e.g. replace with `log.Printf`). Internally, go-mcp uses the standard `log` for fatal errors as well ([GitHub - MegaGrindStone/go-mcp: A Go implementation of the Model Context Protocol (MCP) - an open protocol that enables seamless integration between LLM applications and external data sources and tools.](https://github.com/MegaGrindStone/go-mcp#:~:text=log.Fatal%28err%29%20,)). It does support structured logging in the MCP sense (the server can emit log notifications that a client like Cursor or future Goose versions might display), but that’s separate from stdout/stderr. There isn’t a built-in leveled logger for file output – it’s expected you manage verbosity in your code. The framework makes it easy to plug in your own logging: for example, you can attach hooks (like the `OnClientConnected` callback) and use them to log to stderr in whatever format you want. **Summary:** go-mcp won’t introduce any stdout noise on its own (aside from its examples), supports MCP log events for structured logs, and relies on you to configure how verbose your logging should be (by adding appropriate `log.Print` calls).

- **mcp-golang (metoro-io):** This library focuses on being *“straightforward and well-designed”* with minimal boilerplate ([Building Model Context Protocol Servers in Go: Enhancing AI Tools with Your Data](https://www.bytesizego.com/blog/model-context-protocol-golang#:~:text=After%20exploring%20various%20libraries%2C%20I,implementing%20MCP%20servers%20relatively%20painless)). It doesn’t force any particular logging framework. In practice, mcp-golang itself prints almost nothing by default – it handles requests and responses silently unless an error occurs. On critical failures (like failing to start or parse something), it would return an error or possibly use `log.Fatalf` internally (ensuring the error goes to stderr). There’s no global logger instance or structured logging built in; instead, you get simplicity. You’re free to use Go’s `log` or another logger in your tool handlers. The library ensures protocol correctness, so it will not output extraneous text on stdout. That means using mcp-golang, **your server will only produce output that you explicitly code** – giving you full control to log to stderr as needed. Adjusting logging is as easy as adding or removing `log.Println` calls in your code (or configuring the global logger’s flags/outputs if desired). Since it implements the MCP spec, it does include support for logging notifications and levels (if the client requests them), but again, that’s an in-band JSON mechanism, not an automatic stdout/stderr log. The key point is that mcp-golang won’t surprise you with its own logging; you implement the logging you need, making it easy to stay compatible with Claude Desktop and Goose.

- **mark3labs/mcp-go:** A Go MCP implementation (from the makers of Goose) that provides a complete MCP feature set. It includes support for structured **LoggingMessageNotification** events in the protocol (useful for clients that ask for log streams) ([mcp package - github.com/mark3labs/mcp-go/mcp - Go Packages](https://pkg.go.dev/github.com/mark3labs/mcp-go/mcp#:~:text=LoggingMessageNotification%20is%20a%20notification%20of,which%20messages%20to%20send%20automatically)). By default, this framework doesn’t do much logging to the console on its own. In examples, you might see both `fmt.Printf` and `log.Fatalf` used. For instance, the README shows using `fmt.Printf("Server error: %v\n", err)` if the server fails to start ([GitHub - mark3labs/mcp-go: A Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools.](https://github.com/mark3labs/mcp-go#:~:text=match%20at%20L410%20fmt.Printf%28,err%29)), and elsewhere uses `log.Fatalf` for a similar error ([GitHub - mark3labs/mcp-go: A Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools.](https://github.com/mark3labs/mcp-go#:~:text=match%20at%20L446%20log.Fatalf%28,err%29)). In either case, these are choices in example code – you can replace them or handle errors differently. The core server library methods generally return errors to you instead of printing, so you decide how to log them. **No internal logs are sent to stdout** aside from what you choose to print, so it’s safe for stdio transport. mark3labs/mcp-go does not have a built-in log level configuration for its own logging; you control verbosity by what you output. It supports injecting your own logging if needed (for example, you could wrap tool handler calls with custom loggers). Because this library is designed with Goose in mind, it follows best practices: use stderr for any runtime messages and avoid stdout pollution. **In short:** mark3labs’ framework is similar – critical issues are surfaced as errors (which you can log to stderr), and it fully supports MCP’s logging protocol features but leaves actual console/file logging policy up to the developer. Just ensure that if you use their example code, you redirect any `fmt.Printf` to stderr (e.g. via `log.Print`) to keep Claude and Goose happy ([GitHub - mark3labs/mcp-go: A Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools.](https://github.com/mark3labs/mcp-go#:~:text=fmt.Printf%28%22Server%20error%3A%20,)) ([GitHub - mark3labs/mcp-go: A Go implementation of the Model Context Protocol (MCP), enabling seamless integration between LLM applications and external data sources and tools.](https://github.com/mark3labs/mcp-go#:~:text=match%20at%20L410%20fmt.Printf%28,err%29)).

## Practical Logging Tips (macOS) 
- **Use stderr for all logs:** Whichever framework you use, set your logger to stderr. Go’s default `log` is already on stderr, so leverage that for simplicity. For more structured logging (JSON logs, etc.), direct those outputs to a file or stderr – just not stdout. This guarantees Claude Desktop and Goose will capture it ([Debugging - Model Context Protocol](https://modelcontextprotocol.io/docs/tools/debugging#:~:text=Server)). 

- **Avoid high-frequency stdout printing:** If you have verbose debug info, double-check none of it accidentally goes to stdout. Even a single stray `fmt.Println` can mix into the MCP message stream. During development, monitor the Claude/Goose logs; if something you expected to see isn’t in the logs, it might have gone to stdout by mistake. Conversely, if Claude or Goose reports JSON parse errors or weird behavior, ensure you’re not printing non-JSON to stdout.

- **Leverage log levels in code:** Although Claude Desktop doesn’t have a toggle for “show info vs debug” (it logs whatever you give it), you can implement simple log level control in your Go server. For example, use an environment variable or command-line flag in your server to set a verbosity level, and then conditionally `log.Print` debug messages. That way, you can run a more verbose server locally (and see detailed logs in Claude/Goose) and tone it down later. Since Claude/Goose will record everything, too much junk can make logs hard to read – so controlling it from the server side is wise.

- **Check client developer settings:** On Claude Desktop (macOS), the Developer Tools console can show you if the client is receiving log notifications or encountering errors. And Goose is open source – if needed, you can run it in a terminal with `--verbose` flags (or build a custom version) to troubleshoot how it handles your server’s output. Goose’s own logs (`goose.log`, etc.) already include a lot of detail, but in case you suspect Goose is ignoring something, running it with `RUST_LOG=debug` can confirm what it’s doing internally ([goose Failed to start extension: (all extensions except Developer) · Issue #1763 · block/goose · GitHub](https://github.com/block/goose/issues/1763#:~:text=RUST_BACKTRACE%3Dfull%20RUST_LOG%3Ddebug%20goose%20session%20Failed,%3Cstd%3A%3Asys%3A%3Abacktrace%3A%3ABacktraceLock%3A%3Aprint%3A%3ADisplayBacktrace%20as)).

By following these practices, you’ll ensure that your Go-based MCP server’s debug output is visible and useful during development on macOS. Claude Desktop and Codename Goose will faithfully collect your logs (stderr) so you can debug issues, without ever mixing up protocol data and log data. Keep your logging disciplined, and you’ll have a smooth experience building and testing your MCP server! 

